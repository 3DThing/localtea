# Безопасность в LocalTea

В этом документе описаны механизмы и практики безопасности, реализованные в проекте LocalTea.

## 1. Аутентификация и Управление Сессиями

Проект использует гибридную схему аутентификации на основе JWT (JSON Web Tokens) и сессионных токенов в базе данных.

### Access Token (Токен доступа)
*   **Тип**: JWT (Signed with HS256).
*   **Назначение**: Используется для авторизации запросов к API. Передается в заголовке `Authorization: Bearer <token>`.
*   **Срок жизни**: Короткий (по умолчанию 30 минут).
*   **Содержимое**: ID пользователя, тип токена (`access`), время истечения (`exp`), уникальный ID (`jti`).

### Refresh Token (Токен обновления)
*   **Тип**: Случайная строка UUID4.
*   **Назначение**: Получение нового Access токена без повторного ввода пароля.
*   **Хранение**:
    *   **Клиент**: В `HttpOnly` cookie (`refresh_token`) с флагом `SameSite=Lax`. Это защищает токен от кражи через XSS и ограничивает отправку при CSRF.
    *   **Сервер**: В базе данных хранится **SHA256 хеш** токена. Это гарантирует, что даже при утечке базы данных злоумышленники не смогут использовать активные сессии пользователей.
*   **Срок жизни**: Длительный (по умолчанию 7 дней).
*   **Ротация**: При каждом использовании Refresh токена старый отзывается, и выдается новая пара Access + Refresh токенов.
*   **Отзыв (Revocation)**: Токен можно отозвать (флаг `revoked` в БД), что позволяет принудительно завершить сессию пользователя (Logout).

### Привязка к контексту (Fingerprinting)
При создании сессии (Refresh token) сохраняются данные о клиенте:
*   IP-адрес.
*   User-Agent.
Это позволяет выявлять подозрительную активность и блокировать сессии при смене контекста (например, если токен украден, но IP злоумышленника отличается).

## 2. Хеширование Паролей

Пароли пользователей никогда не хранятся в открытом виде.
*   **Алгоритм**: Argon2.
*   **Библиотека**: `passlib`.
*   **Конфигурация**: `CryptContext(schemes=["argon2"], deprecated="auto")`.
Argon2 является современным победителем конкурса Password Hashing Competition и обеспечивает высокую устойчивость к перебору на GPU/ASIC.

## 3. Защита от CSRF (Cross-Site Request Forgery)

Для защиты от межсайтовой подделки запросов используется механизм **Double Submit Cookie**.

*   **Конфигурация**: Включение/отключение проверки управляется параметром `CSRF_ENABLED` в `config.py`.
*   **Механизм**:
    1.  Сервер генерирует криптографически стойкий токен.
    2.  Токен отправляется клиенту в cookie `csrf_token` (без флага HttpOnly, чтобы JS мог его прочитать) с `SameSite=Lax`.
    3.  При выполнении мутирующих запросов (POST, PUT, DELETE) клиент должен прочитать значение из cookie и отправить его в заголовке `X-CSRF-Token`.
    4.  Сервер проверяет совпадение значения в cookie и в заголовке.
*   **Почему это работает**: Злоумышленник может заставить браузер жертвы отправить запрос (и cookie приложатся автоматически), но он не может прочитать значение cookie с другого домена, чтобы подставить его в заголовок.

## 4. Rate Limiting (Ограничение частоты запросов)

Для защиты от Brute-force атак и спама используется библиотека `slowapi` с хранилищем в Redis.

*   **Глобальные лимиты**: Могут быть настроены при необходимости.
*   **Точечные лимиты**:
    *   `/user/login`: 3 попытки в минуту, 20 в час.
    *   `/user/registration`: 2 попытки в минуту.
    *   `/user/refresh`: 2 попытки в минуту.
*   **Идентификация**: По IP-адресу клиента (`get_remote_address`).

## 5. CORS (Cross-Origin Resource Sharing)

Политика CORS настроена для предотвращения несанкционированных запросов с посторонних доменов.
*   **Разрешенные источники**: Список доменов (например, `https://localtea.ru`, `http://localhost:3000`) задается в переменной `ALLOWED_ORIGINS` в `config.py`.
*   **Credentials**: Разрешены (`allow_credentials=True`) для передачи cookies.

## 6. Валидация данных

*   Все входные данные строго типизированы и валидируются с помощью **Pydantic**. Это предотвращает инъекции и передачу некорректных типов данных.
*   SQL-инъекции предотвращаются использованием ORM **SQLAlchemy** и параметризованных запросов.

## 8. Управление конфигурацией и секретами

Для обеспечения безопасности конфиденциальных данных (пароли, ключи API, настройки БД) используется файл `.env`.

*   **Хранение**: Файл `.env` находится в корне проекта и **исключен** из системы контроля версий (`.gitignore`).
*   **Загрузка**: Приложение загружает переменные окружения через `pydantic-settings` (`backend/core/config.py`).
*   **Docker**: В `docker-compose.yml` используется директива `env_file`, чтобы безопасно передавать переменные в контейнеры.

**Важно**: Никогда не коммитьте файл `.env` в репозиторий! Используйте `.env.example` для шаблона.

## 9. Безопасность Базы Данных

Для минимизации ущерба от потенциальных SQL-инъекций реализован принцип наименьших привилегий на уровне СУБД.

*   **Разделение пользователей**:
    *   `migration_user`: Имеет полные права (DDL) на создание/удаление таблиц. Используется **только** утилитой Alembic при накатке миграций.
    *   `app_user`: Используется основным приложением. Имеет права только на `SELECT`, `INSERT`, `UPDATE`, `DELETE` (DML) в схеме `public`.
*   **Ограничения**:
    *   `app_user` не может выполнять `DROP TABLE`, `TRUNCATE` или изменять структуру БД.
    *   Отключено автоматическое создание таблиц через SQLAlchemy (`create_all`).

## 10. Безопасность Контейнеров (Docker Hardening)

*   **Non-root User**: Приложение в контейнере запускается от пользователя с `UID 10001`, а не от `root`. Это ограничивает возможности злоумышленника в случае выхода из песочницы приложения.
*   **Multi-stage Builds**:
    *   **Dev**: Образ для разработки содержит `bash` и запускается от `root` (для удобства работы с volumes).
    *   **Prod**: Боевой образ **не содержит** оболочки (`/bin/sh`, `/bin/bash`) и запускается от ограниченного пользователя. Это предотвращает выполнение произвольных команд (RCE) через shell.
