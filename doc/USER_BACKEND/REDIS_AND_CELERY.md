# Redis и Celery в LocalTea

В этом документе подробно описано, как и для чего используются Redis и Celery в проекте.

## Redis

Redis используется в проекте как высокопроизводительное хранилище данных в оперативной памяти (In-Memory Data Structure Store). Он выполняет две ключевые функции:

### 1. Брокер сообщений для Celery
Redis выступает в роли посредника (Broker) между основным приложением (FastAPI) и фоновыми воркерами (Celery Workers).
*   **Как это работает**: Когда приложение хочет выполнить задачу асинхронно (например, отправить письмо), оно помещает сообщение с данными задачи в Redis. Воркер Celery постоянно опрашивает Redis, забирает задачу и выполняет её.
*   **Конфигурация**: URL подключения берется из `settings.REDIS_URL` в файле `backend/core/config.py`.

### 2. Хранилище для Rate Limiting (Ограничение запросов)
Библиотека `slowapi`, используемая для защиты API от спама и перебора паролей, хранит счетчики запросов в Redis.
*   **Почему Redis**: Это позволяет синхронизировать лимиты между несколькими экземплярами приложения (если запущено несколько воркеров Uvicorn/Gunicorn) и обеспечивает высокую скорость проверки.
*   **Где используется**:
    *   Логин (`/api/v1/user/login`): Ограничен (например, 3 попытки в минуту).
    *   Обновление токена (`/api/v1/user/refresh`): Ограничено.
*   **Файл конфигурации**: `backend/core/limiter.py`.

---

## Celery

Celery — это распределенная очередь задач, позволяющая выполнять тяжелые или длительные операции в фоновом режиме, не блокируя основной поток обработки HTTP-запросов.

### Конфигурация
*   **Инициализация**: `backend/core/celery_app.py`.
*   **Очереди**:
    *   `main-queue`: Специальная очередь для тестовых задач.
    *   `celery` (default): Стандартная очередь для остальных задач (например, отправки писем).

### Задачи (Tasks)

Задачи определены в файле `backend/worker.py`.

#### 1. `send_email`
*   **Назначение**: Отправка электронных писем пользователям.
*   **Аргументы**: `email_to` (кому), `subject` (тема), `body` (тело письма), `template_name` (имя шаблона), `environment` (контекст шаблона).
*   **Реализация**:
    *   Использует модуль `backend/utils/email.py` для синхронной отправки.
    *   Поддерживает HTML-шаблоны (Jinja2), расположенные в `backend/templates/`.
    *   Использует SMTP-сервер, настроенный в `.env` (SSL/TLS, порт 465).
*   **Когда вызывается**:
    *   **Регистрация**: При создании нового пользователя отправляется письмо с токеном подтверждения (`backend/services/user.py` -> `register_user`).
    *   **Смена Email**: При запросе на смену почты отправляется письмо на новый адрес для подтверждения (`backend/services/user.py` -> `request_email_change`).

#### 2. `check_expired_orders`
*   **Назначение**: Периодическая проверка и отмена неоплаченных заказов.
*   **Расписание**: Запускается каждую минуту (настроено через Celery Beat).
*   **Логика**:
    *   Находит заказы в статусе `awaiting_payment`, созданные более 30 минут назад (настраивается).
    *   Переводит их в статус `cancelled`. *Обоснование: Использование единого статуса отмены для упрощения логики фронтенда и отчетности.*
    *   Возвращает зарезервированные товары на склад (увеличивает `quantity` в `SKU`). *Обоснование: Освобождение стока для других покупателей.*

#### 3. `test_celery`
*   **Назначение**: Тестовая задача для проверки работоспособности очереди.
*   **Особенности**: Использует параметр `acks_late=True` (подтверждение выполнения задачи только после её завершения).
*   **Маршрутизация**: Направляется в очередь `main-queue`.

### Процесс работы (Workflow)

1.  **Инициация**: Пользователь отправляет POST запрос на `/api/v1/user/registration`.
2.  **Обработка**: FastAPI создает пользователя в БД.
3.  **Постановка задачи**: Сервис вызывает `send_email.delay(...)`.
4.  **Передача**: Celery клиент сериализует данные и отправляет их в Redis.
5.  **Ответ пользователю**: API немедленно возвращает ответ (200 OK), не дожидаясь отправки письма.
6.  **Исполнение**:
    *   Запущенный процесс `celery worker` видит новую задачу в Redis.
    *   Забирает её и выполняет функцию `send_email`.
    *   Результат (или лог) записывается.

### Запуск

Для работы асинхронных задач необходимо запустить отдельный процесс воркера:

```bash
celery -A backend.worker worker --loglevel=info
```
