# API Маршруты (Endpoints) модуля Cart

В этом документе описаны маршруты API для работы с корзиной покупок.
Базовый префикс для всех маршрутов: `/api/v1/cart`.

Все маршруты требуют аутентификации пользователя.

### `GET /`
*   **Описание**: Получение текущей корзины пользователя.
*   **Ответ**: Объект `Cart` со списком `items` и общей стоимостью `total_price`.
*   **Примечание**: Если корзина не существует, она будет создана автоматически.

### `POST /items/`
*   **Описание**: Добавление товара (SKU) в корзину.
*   **Тело запроса**: `CartItemCreate`
    *   `sku_id` (Integer): ID торгового предложения.
    *   `quantity` (int): Количество (должно быть > 0).
*   **Ответ**: Обновленный объект `Cart`.
*   **Ошибки**:
    *   404: SKU не найден.
    *   400: Недостаточно товара на складе.

### `PUT /items/{item_id}`
*   **Описание**: Обновление количества товара в корзине.
*   **Параметры**: `item_id` (Integer) - ID записи в корзине (не SKU ID).
*   **Тело запроса**: `CartItemUpdate`
    *   `quantity` (int): Новое количество.
*   **Ответ**: Обновленный объект `Cart`.

### `DELETE /items/{item_id}`
*   **Описание**: Удаление товара из корзины.
*   **Параметры**: `item_id` (Integer).
*   **Ответ**: Обновленный объект `Cart`.

### `DELETE /`
*   **Описание**: Полная очистка корзины.
*   **Ответ**: Пустой объект `Cart`.

## Технические детали реализации

*   **Обновление сессии**: При изменении корзины используется `db.expire(cart)` (синхронный вызов), чтобы сбросить кэш сессии SQLAlchemy и гарантировать получение свежих данных при следующем обращении. *Обоснование: Исправление ошибки `TypeError`, возникавшей при попытке использовать `await` с синхронным методом `expire`.*
