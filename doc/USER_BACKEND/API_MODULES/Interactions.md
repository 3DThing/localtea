# API Маршруты (Endpoints) модуля Interactions (Лайки, Комментарии, Просмотры)

В этом документе описаны маршруты API для работы с социальными взаимодействиями: комментариями, лайками и просмотрами.
Базовый префикс для всех маршрутов: `/api/v1/interactions`.

## Комментарии (Comments)

Комментарии можно оставлять к статьям блога (`article`) и товарам (`product`).

### `POST /comments/`
*   **Описание**: Создание нового комментария.
*   **Требует аутентификации**: Да.
*   **Тело запроса**: `CommentCreate`
    *   `content` (str): Текст комментария.
    *   `article_id` (int, optional): ID статьи.
    *   `product_id` (int, optional): ID товара.
    *   *(Должно быть указано ровно одно поле из `article_id` или `product_id`)*
*   **Ответ**: Созданный объект `Comment`.

### `GET /comments/`
*   **Описание**: Получение списка комментариев для сущности.
*   **Параметры запроса**:
    *   `article_id` (int, optional)
    *   `product_id` (int, optional)
    *   `page` (int, default=1)
    *   `limit` (int, default=20)
*   **Ответ**: Список объектов `Comment` с информацией об авторе и количестве лайков на комментарии.

### `DELETE /comments/{comment_id}`
*   **Описание**: Удаление комментария.
*   **Требует аутентификации**: Да (Автор или Админ).
*   **Параметры**: `comment_id` (Integer).
*   **Ответ**: `204 No Content`.

### `POST /comments/{comment_id}/report`
*   **Описание**: Пожаловаться на комментарий (спам, оскорбления).
*   **Требует аутентификации**: Да.
*   **Параметры**: `comment_id` (Integer).
*   **Тело запроса**: `ReportCreate`
    *   `reason` (str): Причина жалобы.
*   **Ответ**: `201 Created`.

## Лайки (Likes)

Лайки можно ставить статьям, товарам и комментариям.

### `POST /likes/`
*   **Описание**: Поставить лайк (или убрать, если уже стоит - toggle).
*   **Аутентификация**: Опциональная.
*   **Логика уникальности**:
    *   Один пользователь (User ID) или один клиент (User-Agent + IP / Fingerprint) может поставить не более одного лайка на объект.
    *   Если пользователь авторизован -> проверка по `user_id`.
    *   Если аноним -> проверка по `fingerprint` (хеш от IP + User-Agent).
*   **Тело запроса**: `LikeCreate`
    *   `article_id` (int, optional)
    *   `product_id` (int, optional)
    *   `comment_id` (int, optional)
    *   *(Должно быть указано ровно одно поле)*
*   **Ответ**: Статус (`liked: true` или `liked: false`) и обновленное количество лайков сущности.

## Просмотры (Views)

Просмотры отслеживаются для статей и товаров.

### `POST /views/`
*   **Описание**: Регистрация просмотра.
*   **Тело запроса**: `ViewCreate`
    *   `article_id` (int, optional)
    *   `product_id` (int, optional)
*   **Логика**:
    *   Сервер должен проверять уникальность просмотра (по IP или User-ID + TimeWindow), чтобы избежать накрутки.
    *   Обновляет счетчик `views_count` в соответствующей таблице.
*   **Ответ**: `200 OK`.

## Обновление существующих сущностей

В ответы API для `Article` и `Product` добавляются поля счетчиков:
*   `likes_count` (int)
*   `comments_count` (int)
*   `views_count` (int)
*   `is_liked` (bool) - лайкнул ли текущий пользователь этот объект (если авторизован).

## Техническая реализация и Безопасность

### 1. Безопасность и Защита от накруток

*   **Rate Limiting**:
    *   Для эндпоинтов лайков и комментариев применяются строгие лимиты (например, 5 запросов в минуту с одного IP) через `slowapi` (Redis).
    *   Это предотвращает автоматизированный спам и накрутку счетчиков.
*   **XSS Protection (Комментарии)**:
    *   Входящий HTML в комментариях должен очищаться (Sanitization) с помощью библиотеки `bleach` или аналогичной.
    *   Разрешен только безопасный набор тегов (или полный запрет HTML), чтобы предотвратить Stored XSS атаки.
*   **Приватность (GDPR)**:
    *   IP-адреса пользователей не хранятся в открытом виде в таблицах `like` и `view`.
    *   Вместо этого сохраняется хеш (Salted Hash) от IP + User-Agent для проверки уникальности (Fingerprint).

### 2. Производительность и Кэширование (Redis)

Для обеспечения высокой производительности при частых обновлениях счетчиков используется стратегия **Cache Aside + Counter Separation**.

*   **Раздельное кэширование**:
    *   **Контент** (Статья, Товар) кэшируется с долгим TTL (например, 1 час). Ключ: `article:{id}:data`.
    *   **Счетчики** (Лайки, Просмотры) хранятся в Redis отдельно и обновляются атомарно (`INCR`). Ключи: `article:{id}:stats`.
*   **Чтение данных**:
    *   При запросе `GET /articles/{id}` бэкенд собирает ответ из двух источников: статический контент из кэша/БД + динамические счетчики из Redis.
*   **Атомарность**:
    *   Обновление счетчиков в БД происходит через атомарные операции (`likes_count = likes_count + 1`) или синхронизируется из Redis, чтобы избежать Race Conditions.

### 3. Отложенная запись (Write-Behind) для Просмотров

*   Просмотры (`views`) создают высокую нагрузку на запись.
*   **Реализация**:
    1.  При запросе `POST /views/` инкрементируется счетчик в Redis.
    2.  Фоновая задача (Celery Beat) раз в N минут сбрасывает накопленные просмотры из Redis в PostgreSQL одним пакетом (Batch Update).
    3.  Это снижает нагрузку на диск БД и позволяет обрабатывать тысячи просмотров в секунду.
